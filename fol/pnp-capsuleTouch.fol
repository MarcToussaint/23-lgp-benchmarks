QUIT
WAIT
ANY
Terminate

FOL_World{
  hasWait=false
  gamma = 1.
  stepCost = 1.
  timeCost = 0.
}

## basic predicates
is_gripper
is_object
is_place
is_pose
is_box
is_sphere
is_capsule

## predicates to help formulating rules
on
busy
movable


## predicates to help prune tree
INFEASIBLE
INFEASIBLE_pick

## skeleton symbols
above
touch
impulse
restingOn
poseEq
push_
stable
stableOn
quasiStaticOn
dynamic
dynamicOn
liftDownUp

## initial state (generated by the code)
START_STATE {}

### RULES

#####################################################################

### Reward
REWARD {
}

#####################################################################

DecisionRule pick_sphere {
  Obj, From, Hand, 
  { (is_gripper Hand) (is_object Obj) (is_sphere Obj) (on From Obj) (busy Hand)! (INFEASIBLE_pick Hand Obj)! }
  { (on From Obj)! (above Obj From)! (touch Obj From)! (stable From Obj)! (stableOn From Obj)!  #deletes
    (on Hand Obj) (busy Hand) (movable Obj)  #logic
    (positionEq Hand Obj) (stable Hand Obj)  #geometric
    }
}

#####################################################################

DecisionRule pick_capsule {
  Obj, From, Hand,
  { (is_gripper Hand) (is_object Obj) (is_capsule Obj) (on From Obj) (busy Hand)! (INFEASIBLE_pick Hand Obj)! }
  { (on From Obj)! (above Obj From)! (touch Obj From)! (stable From Obj)! (stableOn From Obj)!  #deletes
    (on Hand Obj) (busy Hand) (movable Obj)  #logic
    %(touch Hand Obj) (stable Hand Obj)  #geometric
    }
}

#####################################################################

DecisionRule start_push {
  Stick, Obj, Floor,
  { (movable Stick) (is_object Stick) (is_object Obj) (is_object Floor) (on Floor Obj) (busy Stick)! (on Obj Stick)! }
  { (stable Floor Obj)! (stableOn Floor Obj)!  #deletes
    (busy Stick)  #logic
    (quasiStaticOn Floor Obj) (push_ Stick Obj)  #geometric
    }
}

#####################################################################

DecisionRule end_push {
  Stick, Obj, Floor,
  { (push_ Stick Obj) (on Floor Obj) }
  { (quasiStaticOn Floor Obj)! (push_ Stick Obj)! (busy Stick)!  #deletes
    #logic
    (stableOn Floor Obj)  #geometric
    }
}

#####################################################################

DecisionRule place_capsule {
  Obj, Hand, To,
  { (is_gripper Hand) (is_object Obj) (is_capsule Obj) (on Hand Obj) (is_place To) (is_box To) (busy Obj)! }
  { (busy Hand)! (on Hand Obj)! (stable Hand Obj)! (touch Hand Obj)! (movable Obj)!  #deletes
    (on To Obj)  #logic
    %(restingOn To Obj) (stable To Obj)  #geometric
    }
}

#####################################################################

BLOCKDecisionRule attach_sticks {
  Obj1, Obj2, Hand, Floor,
  { (is_gripper Hand) (is_object Obj1) (on Floor Obj1) (is_object Obj2) (on Hand Obj2) (is_object Floor) }
  { (busy Hand)! (on Hand Obj2)! (stable Hand Obj2)! (touch Hand Obj2)! (movable Obj2)!  #deletes
    (on Obj1 Obj2)  #logic
    %(restingOn  Floor  Obj2) (stable  Obj1 Obj2), %(touch Obj1 Obj2)  #geometric
    }
}

#####################################################################

DecisionRule poseEq {
  Obj, To,
  { (movable Obj) (is_pose To) }
  { #deletes
    #logic
    (poseEq To Obj)  #geometric
    }
}

#####################################################################

Rule chainMovables {
  Obj1, Obj2,
  { (is_object Obj1) (is_object Obj2) (on Obj1 Obj2) (movable Obj1) }
  { (movable Obj2) }
}
